#include <stdio.h> 		/* required for the isalnum function */
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "open_gps.h"
/* Defines required for serial i/o */
#define COM_PORT   1		/* Serial device connected to COM 1 */
#define BAUDRATE_GPS2      4800		/* baud rate = 4800 */
#define CR         0x0d
#define LF         0x0a
#define ESC        0x1b
#define BEEP       0x07

/* Some helpful defines */
#define SPACE	  0x20
#define COMMA	  0x2C
#define MAXSIZE    100		/* GPS at most, sends 80 or so chars per message string.  So set maximum to 100 */

int open_gps(char const *port_name, int data_size)
{
    struct termios newtio;
	int port;
	
	port = open(port_name, O_RDWR | O_NOCTTY);
	
	tcgetattr(port, &newtio);
	cfsetospeed(&newtio, BAUDRATE_GPS);
   	cfsetispeed(&newtio, BAUDRATE_GPS);
    
       //set the number of data bits.
       newtio.c_cflag &= ~CSIZE;  // Mask the character size bits
       newtio.c_cflag |= CS8;
    
       //set the number of stop bits to 1
       newtio.c_cflag &= ~CSTOPB;
    
       //Set parity to None
       newtio.c_cflag &=~PARENB;
    
       //set for non-canonical (raw processing, no echo, etc.)
       newtio.c_iflag = IGNPAR; // ignore parity check close_port(int
       newtio.c_oflag = 0; // raw output
       newtio.c_lflag = 0; // raw input
    
       //Time-Outs -- won't work with NDELAY option in the call to open
       newtio.c_cc[VMIN]  = data_size;   // block reading until RX x characers. If x = 0, it is non-blocking.
       newtio.c_cc[VTIME] = 0;   // Inter-Character Timer -- i.e. timeout= x*.1 s
    
       //Set local mode and enable the receiver
       newtio.c_cflag |= (CLOCAL | CREAD);
    
       //tcflush(port, TCIFLUSH);
	//Set the new options for the port...
	int status=tcsetattr(port, TCSANOW, &newtio);
	
	if (status != 0){ //For error message
		printf("Configuring comport failed\n");
		return status;
	}

	return port;
}

int open_gps2(char const *port_name, int data_size)
{
    struct termios newtio;
	int port;
	
	port = open(port_name, O_RDWR | O_NOCTTY);
	
	tcgetattr(port, &newtio);
	cfsetospeed(&newtio, BAUDRATE_GPS2);
   	cfsetispeed(&newtio, BAUDRATE_GPS2);
    
       //set the number of data bits.
       newtio.c_cflag &= ~CSIZE;  // Mask the character size bits
       newtio.c_cflag |= CS8;
    
       //set the number of stop bits to 1
       newtio.c_cflag &= ~CSTOPB;
    
       //Set parity to None
       newtio.c_cflag &=~PARENB;
    
       //set for non-canonical (raw processing, no echo, etc.)
       newtio.c_iflag = IGNPAR; // ignore parity check close_port(int
       newtio.c_oflag = 0; // raw output
       newtio.c_lflag = 0; // raw input
    
       //Time-Outs -- won't work with NDELAY option in the call to open
       newtio.c_cc[VMIN]  = data_size;   // block reading until RX x characers. If x = 0, it is non-blocking.
       newtio.c_cc[VTIME] = 0;   // Inter-Character Timer -- i.e. timeout= x*.1 s
    
       //Set local mode and enable the receiver
       newtio.c_cflag |= (CLOCAL | CREAD);
    
       //tcflush(port, TCIFLUSH);
	//Set the new options for the port...
	int status=tcsetattr(port, TCSANOW, &newtio);
	
	if (status != 0){ //For error message
		printf("Configuring comport failed\n");
		return status;
	}

	return port;
}

bool read_gps(int port, float &lon, float &lat){

  unsigned char  charRead;	     		/* char read from COM port */
  unsigned char	 stringRead[MAXSIZE]; 		/* Buffer collects chars read from GPS */
  unsigned char  tempString[MAXSIZE];
  char  timeString[12];
  char  latitudeString[11];
  unsigned char  latitudeCardinalString[3];
  char  longitudeString[12];
  unsigned char  longitudeCardinalString[3];

  unsigned char  *pChar;
  unsigned char  dummyChar;

  unsigned  long utcTime, estTime;		/* Coordinated Universal Time and Eastern Standard Time */
  unsigned  long utcHour, estHour;
  unsigned  long utcMinutes, estMinutes;
  unsigned  long utcSeconds, estSeconds;
  unsigned  char lastCommaPosition;

  float     	 latitude;
  int	    	 latDegrees;
  float	    	 latMinutes;

  float 	 longitude;
  int		 longDegrees;
  float		 longMinutes;

  FILE           *gpsFile;	     		/* Text file of GPS strings read */
  unsigned int   j, k;				/* dummy variable */
  unsigned int	 i;		     		/* Number of chars read per GPS message string */
  unsigned int	 numLinesRead;        		/* Number of GPS strings read */
 
  bool flag_DataReady = false;
    dummyChar = 'A'; pChar = &dummyChar;
    
    fd_set read_fds_gps;
    struct timeval no_timeout_gps;
    
    
    
    
    FD_ZERO(&read_fds_gps);
	FD_SET(port, &read_fds_gps);
	no_timeout_gps.tv_sec  = 0;
	no_timeout_gps.tv_usec = 0;
        
        int num_fds_gps = select(port+1, &read_fds_gps, NULL, NULL, &no_timeout_gps);
    		
	if(num_fds_gps > 0){
	//printf("select: %d\n",num_fds_gps);
	int res_isset_gps = FD_ISSET(port , &read_fds_gps);
	 if(res_isset_gps) {
				
			int res = read(port, &charRead, 1);
			if(res < 0){
				printf("Failed to read gps!!\n");
			}
			
			///////////////////////////////////////////////////////////////	
						
				if(charRead == '$') {     /* GPS messages start with $ char */
				  i = 0;
				  numLinesRead++;
				  stringRead[i] = charRead;
				  while(charRead != CR){
				     res = read(port, &charRead, 1);
					if(res < 0){
					printf("Failed to read gps!@#!\n");
					}
				     //if( (charRead != '\0') && (isalnum(charRead) ||  isspace(charRead) || ispunct(charRead)) ) {
					i++;
					stringRead[i] = charRead;
				     //}
				  } 

				  /* By this point, a complete GPS string has been read so save it to file */
				  /* Append the null terminator to the string read */
				  stringRead[i+1] = '\0';

				  /* Analyze string that we collected */
				  j = 0;
				  pChar = stringRead;
				  while(*(pChar+j) != COMMA) {
				       tempString[j] = *(pChar+j);
				       j++;
				  }
				  tempString[j] = '\0';

				  /* Check if string we collected is the $GPGGA message */
				  if(tempString[3] == 'G' && tempString[4] == 'G' && tempString[5] == 'A') {
				      /*
					 Found GPGGA string.  It has 14 commas total.  Its NMEA sentence structure is:

					 $GPGAA,hhmmss.ss,ddmm.mmmm,n,dddmm.mmmm,e,q,ss,y.y,a.a,z,g.g,z,t.t,iii*CC<CR><LF>
					 |    |    |    |    |    |    |    |    |    |    |    |    |    |    |
					 0   	   1         2         3         4         5         6         7
					 0123456789012345678901234567890123456789012345678901234567890123456789012

					 where:

					 GPGAA		: GPS fixed data identifier
					 hhmmss.ss	: Coordinated Universal Time (UTC), also known as GMT
					 ddmm.mmmm,n	: Latitude in degrees, minutes and cardinal sign
					 dddmm.mmmm,e	: Longitude in degrees, minutes and cardinal sign
					 q		: Quality of fix.  1 = there is a fix
					 ss		: Number of satellites being used
					 y.y		: Horizontal dilution of precision
					 a.a,M		: GPS antenna altitude in meters
					 g.g,M		: geoidal separation in meters
					 t.t		: Age of the defferential correction data
					 iiii		: Deferential station's ID
					 *CC		: checksum for the sentence
				      */

				      pChar = stringRead;

				      /* Get UTC time */
				      j = 7;  /* start of time field */
				      k = 0;
				      while(*(pChar+j) != ',') {
					   timeString[k] = *(pChar+j);
					   j++;
					   k++;
				      }
				      lastCommaPosition = j;
				      timeString[k] = '\0';
				      sscanf(timeString, "%ld", &utcTime);
				      utcHour = (utcTime/10000);   /* extract Hours from long */
				      utcMinutes = (utcTime - (utcHour*10000))/100;  /* extract minutes from long */
				      utcSeconds = utcTime - (utcHour*10000) - (utcMinutes*100); /* extract seconds from long */

				      if(utcHour >= 4 && utcHour <= 23) estHour = utcHour - 4;
					else estHour = utcHour + 20;
				      estMinutes = utcMinutes;
				      estSeconds = utcSeconds;

				      /* NB: %02ld formats long to print 2 chars wide, padding with 0 if necessary */
				 //     printf("%02ld:%02ld:%02ld UTC = %02ld:%02ld:%02ld EST", utcHour, utcMinutes, utcSeconds, estHour, estMinutes, estSeconds);

				      /* Get lattitude: ddmm.mmmm */
				      pChar = stringRead;
				      j = lastCommaPosition + 1;
				      k = 0;
				      while(*(pChar+j) != ',') {
					   latitudeString[k] = *(pChar+j);
					   j++;
					   k++;
				      }
				      lastCommaPosition = j;
				      latitudeString[k] = '\0';

				      sscanf(latitudeString, "%f", &latitude);
				      latDegrees = (int)(latitude/100);
				      latMinutes = (float)(latitude - latDegrees*100);
				   //   printf("\t%02d DEG\t%2.4f MIN", latDegrees, latMinutes);

				      /* Get lattitude Cardinal direction */
				      pChar = stringRead;
				      j = lastCommaPosition + 1;
				      k = 0;
				      while(*(pChar+j) != ',') {
					   latitudeCardinalString[k] = *(pChar+j);
					   j++;
					   k++;
				      }
				      lastCommaPosition = j;
				      latitudeCardinalString[k] = '\0';
				     // printf(" %s", latitudeCardinalString);

				      /* Get longitude: dddmm.mmmm */
				      pChar = stringRead;
				      j = lastCommaPosition + 1;
				      k = 0;
				      while(*(pChar+j) != ',') {
					   longitudeString[k] = *(pChar+j);
					   j++;
					   k++;
				      }
				      lastCommaPosition = j;
				      longitudeString[k] = '\0';

				      sscanf(longitudeString, "%f", &longitude);
				      longDegrees = (int)(longitude/100);
				      longMinutes = (float)(longitude - longDegrees*100);
				   //   printf("\t%03d DEG\t%2.4f MIN", longDegrees, longMinutes);

				    //  printf("\n");
				      
				      lon = longDegrees + longMinutes/60.;
				      lat = latDegrees + latMinutes/60.;
				      flag_DataReady = true;
				      
				      //printf("!lon: %f , !lat: %f \n", lon, lat);
				  } /* else not a GPGGA sentence */
				  
				
				  

			      } /* otherwise not a $ character... so loop back until one arrives */
			      else
			      {
			      	 // start byte is wrong
			      }
      
			///////////////////////////////////////////////////////////////	
				
				
					 	
	 	}
	 
	 }
        
        return flag_DataReady;
        
        
        
}
/* Example
int main(void) {

  
  int gps_data_size = 1;
  char const *gps_port_name = "/dev/ttyUSB0";
  float lon, lat;


  int fd_gps = open_gps(gps_port_name, gps_data_size);
  if(fd_gps < 0){
  	printf("%d, Failed to Open GPS Port!!!\n",fd_gps);
  }
  
  while(1){
  	
  	read_gps(fd_gps, lon, lat);
  	//printf("lon: %f , lat: %f \n", lon, lat);
  }
  

  return (0);

} */


